//Выражения и предложения. Выражения (9*9) имеют значения (81)

//2.2 Точка с запятой вставляется после предложения неленейной передачи управления (break, continue, return, throw, yield).
// function a() {
//     return// тоже самое что и return ;
//     console.log('Hello, World')
// }
// a()// вернет undefined так как после return автоматически поставится ;

// условный оператор ? может быть использовано в подобном случае 
// let x = 0;
// let y = 1;
// let max = x > y ? x : y; // 1 
// console.log(max);
// если вам нужно найти большее из двух чисел, то лучше пользоваться Math.max




//2.5 сравнение 
//любое сравнение с NaN дает false
// console.log(NaN < 4)//false
// console.log(NaN > 4)//false
// console.log(NaN == 4)//false

// так же можно сравнивать строки в лексиграфическом порядке 
// console.log('Hello' < 'Goodbye')// false - H следует за G
// console.log('Aa' === 'Aa') //true
// console.log('Aa' > 'AA') //true
// console.log('AA' > 'Aa') //false
// === оператор строго равенста не пропостит операнды равных типов. Числа, булевы значения и строки строго равны, если равны их значения.

//Равенство объектов (включая массивы) означает, что оба операнда ссылаются на один и тот же объект. Ссылки на разные объекты никогда не равны, даже если содержимое объектов одинаково.
// let harry = { name: "Harry", age: 35 };
// let harry2 = harry;
// console.log(harry === harry2)// true - две ссылки на один и тот же объект
// let harry3 = { name: "Harry", age: 35 };
// console.log(harry === harry3)// false - разные объекты






//Логические операторы
//выражение x && y равно true, если оба выражения одновременно равны true
// выражение x || y равно true, если хотя бы один из операндов равен true
// Выраение !x = true, если x = false

// когда операнды не ялвяются белувыми значениями, они возвращают один из операндов в качестве значения выражения.
// console.log(0 && 'Harry');// 0 
// console.log(0 || 'Harry');// 'Harry'






//Циклы for -общая конструкция для обхода элементов.

// for of преобразует элементы итерируемого объекта, чаще всего массива или строки.

// let arr = [, 5, , 9,];
// arr[9] = 108;
// for (const element of arr) {
//     console.log(element); // undefined 5 undefined 9 (5)undefined 108
// }
//цикл посещает все элементы массива с индексами от 0 до arr.length - 1 в порядке возрастания.
//переменная element создается на каждой итерации цикла и инициализирует значение текущего элемента. 


//цикл for in используется для обхода ключей в объекте

// let obj = { name: 'Rick', secondname: "Sanchez" }

// for (let key in obj) {
//     console.log(key); // name  //secondname
//     console.log(`${key}: ${obj[key]}`); // name: Rick // secondname: Sanchez
// }

// let numbers = [1, , 3, 4];

// numbers[99] = 100;
// for (const i in numbers) {
//     console.log(`${i}: ${numbers[i]}`) // '0':1 // '2':'3' ... 
//     // здесь i присваивается значение строки
// }








// Break и continue
//Иногда требуется выйти из цикла сразу после того, как цель достигнута. Допустим, мы ищем позицию первого отрицательного элемента в массиве
//Встретив отрицательный элемент, мы хотим просто выйти из цикла, так чтобы переменная i создержала позицию элемента. Именно для этого и предназначено предложение break.

// let i = 0;
// let arr = [0, 1, 2, 3, 4, -5, 6]
// while (i < arr.length) {
//     if (arr[i] < 0) break;
//     i++;
// }
// console.log(i);// 5
// console.log(arr[5])
// сюда попадаем после break или в результате нормального завершения цикла

// Без предложения break всегда можно обойтись. Можно добавить булеву переменную, которая будет управлять завершением цикла, часто ее называют done или found:
// let i = 0;
// let found = false;
// let arr = [0, 1, 2, 3, 4, -5, 6];
// while (!found && i < arr.length) {
//     if (arr[i] < 0) {
//         found = true;
//     } else {
//         i++;
//     }
// }
// console.log(i);// 5



//Существует предложение break с меткой, которое позволяет выйти из нескольких вложенных циклов
// Пусть требуется найти положение первого отрицательного элемента в двумерном массиве. Когда элемент будет найден, нам понадобится выйти сразу из двух циклов. Добавим метку (идетификатор, за которым следует двоеточие) перед внешним циклом. Предложение break с меткой переходит на предложение, расположенное после помеченного цикла

// let arr = [0, 1, 2, 3, 4, [0, 1, 2, 3, 4, -5, 6], 6];
// let i = 0;
// let j = 0;
// outer:
// while (i < arr.length) {
//     while (j < arr[i].length) {
//         if (arr[i][j] < 0) break outer;
//         j++;
//     }
//     i++
//     j = 0; // обнуляем 
// }
// console.log(`i:${i} j:${j}`); //i:5 j:5



// continue 

//ВЫчислим среднее значение положительных элементов массива
let arr = [1, -1, 2, -2, 3, -3];

let count = 0;
let sum = 0;
for (let i = 0; i < arr.length; i++) {
    if (arr[i] <= 0) continue; // если i-тый элемент массива меньше или равен 0 пропускаем данную итерацию
    count++;
    sum += arr[i];
}
console.log(sum);
