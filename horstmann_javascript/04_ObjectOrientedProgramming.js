// let rick = {
//     name: 'Rick Sanchez',
//     phraze: "Wubba Lubba Dub Dub",
//     yearBorn: 1950,
//     presentYear: 2021,
// };
// Согласно классическому определению, у объекта имеется идентичность, состояние и поведение.
//объект rick обладает идентичностью, - он отличается от любого другого объекта.
// Состояние объекта определяется его свойствами.
//Добавим поведение в виде "метода" т.е свойства, значением которого является функция:
// rick.age = function (x, y) {
//     x = this.yearBorn;
//     y = this.presentYear;
//     return y - x;
// }
// console.log(rick.age());// 71
// rick.version = 'c-137';
// console.log(rick);

// let harry = { name: 'Harry Smith', salary: 90000 };

// harry = {
//     name: 'Harry Smith',
//     salary: 90000,
//     raiseSalary: function (percent) {
//         this.salary = 1 + percent / 100; //При вызове функции this ссылается на объект, указанный слева от точки.
//     }

// }
// // теперь можно повысить зарплату работнику, применив знакомую нотацию с точкой:
// harry.raiseSalary(10);
// console.log(harry.raiseSalary(10))//undefined


// ==== Прототипы prototype

//Предположим, что имеется много объектов работников, похожих на показанный пример. И мы хотим включить свойство raiseSalary в каждый из них. 
//Для автоматизации этой задачи можно написать фабричную функцию:
// function createEmployee(name, salary) {
//     return {
//         name: name,
//         salary: salary,
//         raiseSalary: function (percent) {
//             this.salary *= 1 + percent / 100
//         }
//     }
// }
// Но все равно у каждого объекта работника имеется собственное свойство  raiseSalary, пусть его значениями являются одинаковые функции, было бы лучше, если все разделяли бы одну общую функцию

//Именно для этого предназначены прототипы.  В прототипе собраны свойства, общие для нескольких объектов.  Вот как выглядит такой прототип

// const employeePrototype = {
//     raiseSalary: function (percent) {
//         this.salary *= 1 + percent / 100
//     }
// }



//======= Конструкторы 

function Employee(name, salary) {
    this.name = name
    this.salary = salary
}

// при вызове
new Employee('Harry Potter', 90000)// оператор new создаеь новый пустой объект, а затем вызывает функцию-конструктор. В теле функции Employee устанавливаются свойства объекта с помощью параметра this. - этот объект становится значением выражения new
// Не возвращайте результат функции-конструктора, иначе значением выражения new станет это возвращенное значение, а не вновь созданный объект.

// помимо вызова конструктора, выражение new выполняет еще одно важное действие: заполняет внутренний слот [[Prototype]]

// const harry = new Employee('Harry Smith', 90000);
// console.log(harry)

//детально по шагам 

// 1. Оператор new создает новый объект.
// 2. Во внутренний слот [[Prototype]] этого объекта записывается объект Employee.prototype
// 3. Оператор new вызывает функцию-конструктор с тремя параметрами this(указывает на только что созданный объект), name и salary.
// 4. В теле функции Employee устанавливаются свойства объекта, для чего используется параметр this
// 5.Конструктор возвращает управление, значение параметра new является полностью инициализированный к этому моменту объект.
// 6. Переменная harry инициализируется ссылкой на объект.

// Согласно определению из учебника, классом называется множество объектов, обладающих одинаковым поведением, которое определяется методами.




// ======== Подклассы

// Учебный пример - иерархия наследовпания с суперклассом Employee и подкласом Manager. Ожидается, что работники получают за свою работу зарплату, а менеджеры, помимо основной зарплаты, получают бонусы, если достигают поставленной цели. Для выражения такой связи между классами служит ключевое слово extends: 

// class Employee {
//     constructor(name, salary) { ... }
//     raiseSalary(percent) { ... }
//         ...
// }

// class Manager extends Employee {
//     getSalary(){ return this.salary + this.bonus}
//     ...
// }
